# 항해 99 TIL - 2022.12.12

### 항해 99 TIL 일지

### Node.js 심화 주차

1. 도메인 (Domain)

- 개발자 대부분은 비즈니스 프로세스를 개선하거나 자동화하기 위해 일한다
- 도메인은 이런 프로세스가 지원하는 활동
  - eg1. 가구 판매 회사의 도메인: 구매 및 조달, 제품 설계, 물류 및 배달 등의 분야
  - eg2. 온라인 서점
    - **도메인 구성** : 주문, 회원, 혜택, 결제, 배송, 정산, 카탈로그, 리뷰
    - **하위 도메인**은 **다른** 하위 도메인과 **연동**하여 완전한 기능을 제공합니다.
      - ex) 고객 → 물건 주문 → 결제 → 배송 → 혜택 제공
- 도메인 모델 (Domain Model)
  - 유용한 특성을 포함하는 프로세스나 현상의 지도(Map)
  - 특정 도메인을 개념적으로 정리한 모델
  - 도메인 모델링 (Domain Modeling)의 종류
    1. **엔티티 (Entity)**
    - 실제 DB 테이블과 연관되어 있는 핵심 클래스이고, 엔티티를 기준으로 테이블이 생성되고 DB 스키마가 변경됨
    - 엔티티를 요청(Request)이나 응답값(Response)으로 전달하는 클래스로 사용하면 안됨
    - 엔티티 내부의 속성이 변경되더라도 여전히 동일한 엔티티로 남아있음
    - 엔티티는 시간에 따라 변하는 속성이 포함될 수 있음
    - 어떤 요소가 **엔티티**를 **유일하게 식별**하는지 **정의**하는 것 또한 중요하다
      - 보통 이름이나 참조 번호 등을 사용합니다.
      - ex) `User` 클래스의 `userId`
    2. **값 객체 (Value object)**
    3. **도메인 서비스 (Domain service)**

2. 아키텍처 패턴 (Architecture Pattern)

- 소프트웨어의 구조를 구성하기위한 가장 기본적인 토대를 제시
- 각각의 시스템들과 그 역할이 정의되어 있고, 여러 시스템 사이의 관계와 규칙 등이 포함되어 있음
- 검증된 구조로 개발을 진행하기 때문에 안정적인 개발이 가능
- 아키텍처 패턴을 도입할 경우 도메인이 복잡할수록 모델이나 코드를 더 쉽게 변경할 수 있다
- **대표적인 아키텍처 패턴**
  1. **저장소 패턴 (Repository pattern)**
  - **영속적인 저장소**에 대한 **추상화**
  2. **서비스 계층 패턴 (Service layer pattern)**
  - 유스 케이스(Usecase)의 **시작**과 **끝**을 명확하게 정의하기 위한 패턴
  3. **작업 단위 패턴 (Unit of work pattern)**
  - 원자적 연산을 제공합니다.
  4. **애그리게이트 패턴 (Aggregate pattern)**
  - 데이터 정합성을 강화하기 위한 패턴
- 아키텍처 패턴을 도입하기 전에 고민해야 할 것
  - 아키텍처 패턴이 주는 이익과 비용에 대해 확실한 이유가 있어야 함
  - 여러 계층을 추가하기 위해 들이는 노력과 시간을 투자할 만한 가치가 있을 정도로 어플리케이션과 도메인이 복잡한 경우에만 아키텍처 패턴을 도입해야 함

3. 계층형 아키텍처 패턴 (Layered Architecture Pattern)

- 계층을 분리해서 관리하는 아키텍처 패턴 (현재 가장 흔히 쓰임)
- 단순하고 대중적이면서 비용도 적게 들어 모든 어플리케이션의 사실상 표준 아키텍처
- 어떤 경우든 계층을 분리해서 유지하고, 각 계층이 자신의 바로 아래 계층에만 의존하게 만드는 것이 목표
- 계층화의 핵심은 각 계층은 응집도(Cohesion)가 높으면서, 다른 계층과는 낮은 결합도(Coupling)를 가지고 있어야 함
- 상위 계층은 하위 계층을 사용할 수 있지만, 하위 계층은 자신의 상위 계층에 누가 있는지 알 수 없고, 사용할 수 조차 없도록 구성해야 함
- 규모가 작은 어플리케이션의 경우 3개, 크고 복잡한 경우는 그 이상의 계층으로 구성
- 3계층 아키텍쳐의 계층
  - **프레젠테이션 계층 (Presentation Layer)**
  - **비즈니스 로직 계층 (Business Logic Layer)**
  - **데이터 엑세스 계층 (Data Access Layer)**
- 장점
  - 관심사를 분리하여 현재 구현하려하는 코드를 명확하게 인지
  - 각 계층별로 의존성이 낮아 모듈을 교체하더라도 코드 수정이 용이
  - 각 계층별로 단위 테스트를 작성할 수 있어 테스트 코드를 조금 더 용이하게 구성
- 3계층 아키텍쳐 (3-Layered Architecture) 처리 과정
  1. **Controller** : 어플리케이션의 가장 바깥 부분, 요청/응답을 처리
  - 클라이언트의 **요청**을 처리 한 후 서버에서 처리된 **결과**를 **반환**해주는 **역할**
  2. **Service** : 어플리케이션의 중간 부분, 실제 중요한 작동이 많이 일어나는 부분
     - 아키텍처의 가장 핵심적인 **비즈니스 로직**이 수행되는 부분
  3. **Repository** : 어플리케이션의 가장 안쪽 부분, DB와 맞닿아 있음
     - 실제 **데이터베이스**의 데이터를 사용하는 계층
- 3계층 아키텍쳐의 플로우
  1. 클라이언트(Client)가 요청(Request)을 보냄
  2. 요청(Request)을 URL에 알맞은 컨트롤러(Controller)가 수신
  3. 컨트롤러(Controller)는 넘어온 요청을 처리하기 위해 서비스(Service)를 호출
  4. 서비스(Service)는 필요한 데이터를 가져오기위해 저장소(Repository)에게 데이터를 요청
  5. 서비스(Service)는 저장소(Repository)에서 가져온 데이터를 가공하여 컨트롤러(Controller)에게 데이터를 넘김
  6. 컨트롤러(Controller)는 서비스(Service)의 결과물(Response)을 클라이언트(Client)에게 전달

4. 테스트 코드

- 코드에 문제가 없는지 테스트하기 위해 작성하는 코드
- `Testing shows the presence of defects, not their absence`
- 테스트 코드 종류

  - 단위 테스트 (Unit Test): 가장 작은 규모의 기능을 테스트
  - 통합 테스트 (Integration Test): 여러가지 기능을 합쳤을때 생기는 문제를 방지하기 위한 테스트
  - E2E 테스트 (End-to-end Test): 백엔드부터 웹 페이지가 의도한대로 동작하고 데이터를 보여주는지 테스트

  ```
  // 설치
  npm init -y
  npm i jest -D

  // package.json 수정
  "scripts": {
    "test": "jest" // before) "echo \"Error: no test specified\" && exit 1"
  },

  // 테스트 하기
  (파일이름).spec.js
  npm run test

  // 통합 테스트용 DB 생성
  // 1. config.json의 "test"부분 DB에 연결

  // test 환경에 설정값을 이용해 DB를 생성 (terminal)
  NODE_ENV=test npx sequelize db:create

  // test 환경에 설정값을 이용해 Table을 생성 (terminal)
  NODE_ENV=test npx sequelize db:migrate

  // test 실행 코드 (작성해둔 package.json의 scripts 참조)
  npm run test:unit // 유닛 테스트
  npm run test:integration // 통합테스트
  npx jest -- verbose -- coverage // 테스트 코드로 커버한 파일들 확인
  ```
